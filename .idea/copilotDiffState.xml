<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/batch/reader/ProteinStaxReader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/batch/reader/ProteinStaxReader.java" />
              <option name="originalContent" value="package com.example.batch.reader;&#10;&#10;import com.example.batch.model.ProteinEntry;&#10;import lombok.SneakyThrows;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.batch.item.support.AbstractItemStreamItemReader;&#10;&#10;import java.io.*;&#10;import java.util.zip.GZIPInputStream;&#10;import javax.xml.stream.XMLInputFactory;&#10;import javax.xml.stream.XMLStreamReader;&#10;import javax.xml.stream.XMLStreamException;&#10;&#10;@Slf4j&#10;public class ProteinStaxReader extends AbstractItemStreamItemReader&lt;ProteinEntry&gt; {&#10;    private XMLStreamReader reader;&#10;    private final String filePath;&#10;&#10;    int proteinCount = 0;&#10;&#10;    public ProteinStaxReader(String filePath) {&#10;        this.filePath = filePath;&#10;        initializeReader();&#10;    }&#10;&#10;    private void initializeReader() {&#10;        try {&#10;            FileInputStream fis = new FileInputStream(filePath);&#10;            InputStream inputStream;&#10;&#10;            // Check if file is gzipped by extension&#10;            if (filePath.endsWith(&quot;.gz&quot;)) {&#10;                inputStream = new GZIPInputStream(new BufferedInputStream(fis));&#10;            } else {&#10;                inputStream = new BufferedInputStream(fis);&#10;            }&#10;&#10;            // Use PushbackInputStream to handle BOM&#10;            PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream, 3);&#10;&#10;            // Check for BOM and skip if present&#10;            byte[] bom = new byte[3];&#10;            int bytesRead = pushbackInputStream.read(bom);&#10;&#10;            if (bytesRead &gt;= 3 &amp;&amp; bom[0] == (byte) 0xEF &amp;&amp; bom[1] == (byte) 0xBB &amp;&amp; bom[2] == (byte) 0xBF) {&#10;                // UTF-8 BOM found, don't push back&#10;            } else {&#10;                // No BOM, push back what we read&#10;                pushbackInputStream.unread(bom, 0, bytesRead);&#10;            }&#10;&#10;            // Use pushbackInputStream instead of inputStream&#10;            InputStreamReader isr = new InputStreamReader(pushbackInputStream, &quot;UTF-8&quot;);&#10;&#10;            XMLInputFactory factory = XMLInputFactory.newInstance();&#10;            factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);&#10;            factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);&#10;            reader = factory.createXMLStreamReader(isr);&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to initialize XML reader&quot;, e);&#10;        }&#10;    }&#10;&#10;    public ProteinEntry read() throws XMLStreamException {&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT &amp;&amp; &quot;entry&quot;.equals(reader.getLocalName())) {&#10;                return parseEntry();&#10;            }&#10;&#10;//            if (event == XMLStreamReader.END_DOCUMENT) {&#10;//                return null; // End of file&#10;//            }&#10;            if (proteinCount &gt; 1000) {&#10;                log.info(&quot;Protein count is too large, stopping read.&quot;);&#10;                return null; // Limit to 1000 proteins for testing&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ProteinEntry parseEntry() throws XMLStreamException {&#10;&#10;        proteinCount++;&#10;        String accession = null;&#10;        String sequence = null;&#10;        String taxId = null;&#10;&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT) {&#10;                String elementName = reader.getLocalName();&#10;&#10;                switch (elementName) {&#10;                    case &quot;accession&quot;:&#10;                        if (accession == null) { // Take first accession as primary&#10;                            accession = reader.getElementText();&#10;                        }&#10;                        break;&#10;&#10;                    case &quot;sequence&quot;:&#10;                        sequence = reader.getElementText().replaceAll(&quot;\\s&quot;, &quot;&quot;); // Remove whitespace&#10;                        break;&#10;                    case &quot;organism&quot;:&#10;                        taxId = parseOrganism();&#10;                        break;&#10;&#10;//                    case &quot;dbReference&quot;:&#10;//                        if (&quot;NCBI Taxonomy&quot;.equals(reader.getAttributeValue(null, &quot;type&quot;))) {&#10;//                            taxId = reader.getAttributeValue(null, &quot;id&quot;);&#10;//                        }&#10;//                        break;&#10;                }&#10;            }&#10;&#10;            if (event == XMLStreamReader.END_ELEMENT &amp;&amp; &quot;entry&quot;.equals(reader.getLocalName())) {&#10;                break; // End of current entry&#10;            }&#10;        }&#10;&#10;        if (accession != null &amp;&amp; sequence != null &amp;&amp; taxId != null) {&#10;            return new ProteinEntry(accession, sequence, taxId);&#10;        }&#10;&#10;        return null; // Skip entries without required data&#10;    }&#10;&#10;    private String parseOrganism() throws XMLStreamException {&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT &amp;&amp; &quot;dbReference&quot;.equals(reader.getLocalName())) {&#10;                if (&quot;NCBI Taxonomy&quot;.equals(reader.getAttributeValue(null, &quot;type&quot;))) {&#10;                    return reader.getAttributeValue(null, &quot;id&quot;);&#10;                }&#10;            }&#10;&#10;            if (event == XMLStreamReader.END_ELEMENT &amp;&amp; &quot;organism&quot;.equals(reader.getLocalName())) {&#10;                break; // End of organism tag&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    @SneakyThrows&#10;    public void close() {&#10;        if (reader != null) {&#10;            reader.close();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.batch.reader;&#10;&#10;import com.example.batch.model.ProteinEntry;&#10;import lombok.SneakyThrows;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.batch.item.support.AbstractItemStreamItemReader;&#10;&#10;import java.io.*;&#10;import java.util.zip.GZIPInputStream;&#10;import javax.xml.stream.XMLInputFactory;&#10;import javax.xml.stream.XMLStreamReader;&#10;import javax.xml.stream.XMLStreamException;&#10;&#10;@Slf4j&#10;public class ProteinStaxReader extends AbstractItemStreamItemReader&lt;ProteinEntry&gt; {&#10;    private XMLStreamReader reader;&#10;    private final String filePath;&#10;&#10;    int proteinCount = 0;&#10;&#10;    public ProteinStaxReader(String filePath) {&#10;        this.filePath = filePath;&#10;        initializeReader();&#10;    }&#10;&#10;    private void initializeReader() {&#10;        try {&#10;            FileInputStream fis = new FileInputStream(filePath);&#10;            InputStream inputStream;&#10;&#10;            // Check if file is gzipped by extension&#10;            if (filePath.endsWith(&quot;.gz&quot;)) {&#10;                inputStream = new GZIPInputStream(new BufferedInputStream(fis));&#10;            } else {&#10;                inputStream = new BufferedInputStream(fis);&#10;            }&#10;&#10;            // Use PushbackInputStream to handle BOM and leading whitespace&#10;            PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream, 128);&#10;&#10;            // Check for BOM and skip if present&#10;            byte[] bom = new byte[3];&#10;            int bytesRead = pushbackInputStream.read(bom);&#10;&#10;            if (bytesRead &gt;= 3 &amp;&amp; bom[0] == (byte) 0xEF &amp;&amp; bom[1] == (byte) 0xBB &amp;&amp; bom[2] == (byte) 0xBF) {&#10;                // UTF-8 BOM found, don't push back&#10;            } else {&#10;                // No BOM, push back what we read&#10;                pushbackInputStream.unread(bom, 0, bytesRead);&#10;            }&#10;&#10;            // Skip any leading whitespace before XML declaration&#10;            ByteArrayOutputStream leading = new ByteArrayOutputStream();&#10;            int b;&#10;            boolean foundStart = false;&#10;            while ((b = pushbackInputStream.read()) != -1) {&#10;                if (!Character.isWhitespace(b)) {&#10;                    pushbackInputStream.unread(b);&#10;                    foundStart = true;&#10;                    break;&#10;                }&#10;                leading.write(b);&#10;            }&#10;            if (!foundStart) {&#10;                throw new IOException(&quot;No XML content found in file.&quot;);&#10;            }&#10;&#10;            InputStreamReader isr = new InputStreamReader(pushbackInputStream, &quot;UTF-8&quot;);&#10;&#10;            XMLInputFactory factory = XMLInputFactory.newInstance();&#10;            factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);&#10;            factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);&#10;            reader = factory.createXMLStreamReader(isr);&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to initialize XML reader&quot;, e);&#10;        }&#10;    }&#10;&#10;    public ProteinEntry read() throws XMLStreamException {&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT &amp;&amp; &quot;entry&quot;.equals(reader.getLocalName())) {&#10;                return parseEntry();&#10;            }&#10;&#10;//            if (event == XMLStreamReader.END_DOCUMENT) {&#10;//                return null; // End of file&#10;//            }&#10;            if (proteinCount &gt; 1000) {&#10;                log.info(&quot;Protein count is too large, stopping read.&quot;);&#10;                return null; // Limit to 1000 proteins for testing&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private ProteinEntry parseEntry() throws XMLStreamException {&#10;&#10;        proteinCount++;&#10;        String accession = null;&#10;        String sequence = null;&#10;        String taxId = null;&#10;&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT) {&#10;                String elementName = reader.getLocalName();&#10;&#10;                switch (elementName) {&#10;                    case &quot;accession&quot;:&#10;                        if (accession == null) { // Take first accession as primary&#10;                            accession = reader.getElementText();&#10;                        }&#10;                        break;&#10;&#10;                    case &quot;sequence&quot;:&#10;                        sequence = reader.getElementText().replaceAll(&quot;\\s&quot;, &quot;&quot;); // Remove whitespace&#10;                        break;&#10;                    case &quot;organism&quot;:&#10;                        taxId = parseOrganism();&#10;                        break;&#10;&#10;//                    case &quot;dbReference&quot;:&#10;//                        if (&quot;NCBI Taxonomy&quot;.equals(reader.getAttributeValue(null, &quot;type&quot;))) {&#10;//                            taxId = reader.getAttributeValue(null, &quot;id&quot;);&#10;//                        }&#10;//                        break;&#10;                }&#10;            }&#10;&#10;            if (event == XMLStreamReader.END_ELEMENT &amp;&amp; &quot;entry&quot;.equals(reader.getLocalName())) {&#10;                break; // End of current entry&#10;            }&#10;        }&#10;&#10;        if (accession != null &amp;&amp; sequence != null &amp;&amp; taxId != null) {&#10;            return new ProteinEntry(accession, sequence, taxId);&#10;        }&#10;&#10;        return null; // Skip entries without required data&#10;    }&#10;&#10;    private String parseOrganism() throws XMLStreamException {&#10;        while (reader.hasNext()) {&#10;            int event = reader.next();&#10;&#10;            if (event == XMLStreamReader.START_ELEMENT &amp;&amp; &quot;dbReference&quot;.equals(reader.getLocalName())) {&#10;                if (&quot;NCBI Taxonomy&quot;.equals(reader.getAttributeValue(null, &quot;type&quot;))) {&#10;                    return reader.getAttributeValue(null, &quot;id&quot;);&#10;                }&#10;            }&#10;&#10;            if (event == XMLStreamReader.END_ELEMENT &amp;&amp; &quot;organism&quot;.equals(reader.getLocalName())) {&#10;                break; // End of organism tag&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    @SneakyThrows&#10;    public void close() {&#10;        if (reader != null) {&#10;            reader.close();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>